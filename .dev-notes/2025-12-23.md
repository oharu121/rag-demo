# Dev Notes - 2025-12-23

## Horizontal Mouse Wheel Scroll for DocumentChipsBar

### Problem
The `DocumentChipsBar` component has a horizontal scrollable area (`overflow-x-auto`) for document chips, but users couldn't scroll it using the mouse wheel. This is a common UX issue - users expect to scroll horizontally when hovering over a horizontal scrollable area.

### Solution
Added a `useEffect` hook that attaches a wheel event listener to convert vertical scroll (deltaY) into horizontal scroll (scrollLeft).

```tsx
const scrollContainerRef = useRef<HTMLDivElement>(null);

useEffect(() => {
  const container = scrollContainerRef.current;
  if (!container) return;

  const handleWheel = (e: WheelEvent) => {
    if (e.deltaY !== 0) {
      e.preventDefault();
      container.scrollLeft += e.deltaY;
    }
  };

  container.addEventListener("wheel", handleWheel, { passive: false });
  return () => container.removeEventListener("wheel", handleWheel);
}, [documents.length]); // Important: dependency on documents.length
```

### Key Implementation Details

1. **`passive: false`** - Required to call `e.preventDefault()`. Without this, the browser may ignore `preventDefault()` for performance reasons.

2. **`e.preventDefault()`** - Prevents the default vertical page scroll when hovering over the chips bar.

3. **Dependency array `[documents.length]`** - This was the critical fix! The component has an early return:
   ```tsx
   if (documents.length === 0) return null;
   ```

   When the component first mounts, documents might be empty (loading state), so the ref container is `null`. The `useEffect` with `[]` runs once on mount but finds no container. When documents load later, the component re-renders with the scroll container, but the `useEffect` doesn't run again.

   Adding `documents.length` to the dependency array ensures the effect re-runs after documents are loaded and the scroll container is rendered.

4. **Separate ref for scroll container** - The component uses `forwardRef` for the outer div (used by parent for other purposes), so we need a separate internal ref (`scrollContainerRef`) for the scrollable area.

### Structure
```tsx
<div ref={ref}> {/* forwardRef - outer container */}
  <div className="flex items-center gap-2">
    <span>ドキュメント:</span> {/* Fixed label */}
    <div
      ref={scrollContainerRef}  {/* Scrollable container */}
      className="overflow-x-auto scrollbar-hide"
    >
      {/* chips */}
    </div>
  </div>
</div>
```

The label is outside the scrollable container so it stays fixed while chips scroll.

### Testing
You can verify the scroll is working by running this in browser console:
```javascript
const container = document.querySelector('.overflow-x-auto.scrollbar-hide');
const event = new WheelEvent('wheel', { deltaY: 100, bubbles: true, cancelable: true });
container.dispatchEvent(event);
console.log('Scrolled to:', container.scrollLeft); // Should be > 0
```
