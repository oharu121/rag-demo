# RAG Learning Notes - 2025-12-02

## Document Preview Modal Feature

### Overview

Added a feature to preview document contents in a modal when clicking on document items (both in the welcome screen document chips and in the document management drawer).

### Implementation

#### Backend Changes

**1. New Schema (`backend/app/models/schemas.py`)**

```python
class DocumentContentResponse(BaseModel):
    """ドキュメント内容レスポンス"""
    id: str
    filename: str
    content: str
    line_count: int
```

**2. New Service Method (`backend/app/services/document_service.py`)**

```python
def get_document_content(self, doc_id: str) -> tuple[DocumentInfo, str]:
    """ドキュメントの内容を取得"""
    # サンプルドキュメントを検索
    for file_path in self.settings.documents_dir.glob("**/*.txt"):
        content = file_path.read_text(encoding="utf-8")
        if self._generate_id(file_path.name, content) == doc_id:
            # ... return doc_info, content

    # アップロードされたドキュメントを検索
    for file_path in self.settings.uploads_dir.glob("**/*.txt"):
        content = file_path.read_text(encoding="utf-8")
        if self._generate_id(file_path.name, content) == doc_id:
            # ... return doc_info, content

    raise DocumentException(ErrorMessages.DOCUMENT_NOT_FOUND, "NOT_FOUND")
```

**3. New Endpoint (`backend/app/routers/documents.py`)**

```python
@router.get("/{doc_id}/content", response_model=DocumentContentResponse)
async def get_document_content(doc_id: str) -> DocumentContentResponse:
    """ドキュメントの内容を取得"""
    doc_service = get_document_service()
    doc_info, content = doc_service.get_document_content(doc_id)
    return DocumentContentResponse(
        id=doc_info.id,
        filename=doc_info.filename,
        content=content,
        line_count=doc_info.line_count,
    )
```

#### Frontend Changes

**1. New Type (`frontend/lib/types.ts`)**

```typescript
export interface DocumentContentResponse {
  id: string;
  filename: string;
  content: string;
  line_count: number;
}
```

**2. New API Function (`frontend/lib/api.ts`)**

```typescript
export async function fetchDocumentContent(
  docId: string
): Promise<{ content: string; filename: string; lineCount: number }> {
  const response = await fetch(
    `${baseUrl}${endpoints.documents}/${docId}/content`
  );
  // ... error handling
  const data: DocumentContentResponse = await response.json();
  return {
    content: data.content,
    filename: data.filename,
    lineCount: data.line_count,
  };
}
```

**3. New Component (`frontend/app/components/DocumentPreviewModal.tsx`)**

A modal component that:
- Takes a `doc` prop (Document | null)
- Fetches content on mount using `useEffect`
- Shows loading spinner while fetching
- Displays error message if fetch fails
- Renders document content in a scrollable `<pre>` block
- Closes on backdrop click or Escape key

**4. Updated Components**

- `DocumentList.tsx`: Added `onPreview` prop to make items clickable
- `DocumentDrawer.tsx`: Added modal state and integrated `DocumentPreviewModal`
- `ChatInterface.tsx`: Added modal state for welcome screen document chips

### Debugging the 404 Issue

Initially, the endpoint returned a generic FastAPI 404 `{"detail":"Not Found"}` instead of our custom error. This indicated the route wasn't being matched.

#### Debug Approach

**1. Added debug routes endpoint:**

```python
@router.get("/debug/routes")
async def debug_routes():
    """デバッグ用: ルート確認"""
    return {
        "message": "Documents router is working",
        "available_routes": [...]
    }
```

**2. Added test endpoint with detailed response:**

```python
@router.get("/debug/test-content/{doc_id}")
async def debug_test_content(doc_id: str):
    """デバッグ用: コンテンツエンドポイントのテスト"""
    doc_service = get_document_service()
    all_docs = doc_service.list_documents()
    doc_ids = [d.id for d in all_docs]
    return {
        "received_doc_id": doc_id,
        "available_doc_ids": doc_ids,
        "doc_id_found": doc_id in doc_ids,
    }
```

**3. Added startup route logging (`backend/app/main.py`):**

```python
# 登録されたルートを出力
print("=" * 50, flush=True)
print("登録されたルート:", flush=True)
for route in app.routes:
    if hasattr(route, "methods") and hasattr(route, "path"):
        print(f"  {route.methods} {route.path}", flush=True)
print("=" * 50, flush=True)
```

**4. Added detailed logging in endpoint:**

```python
print(f"[DEBUG] get_document_content called with doc_id: {doc_id}", flush=True)
print(f"[DEBUG] Searching for document: {doc_id}", flush=True)
print(f"[DEBUG] Found document: {doc_info.filename}", flush=True)
```

#### Key Insight: FastAPI Route Matching

When getting a generic `{"detail":"Not Found"}` from FastAPI, it means:
- The route itself isn't being matched (not our custom error)
- Check route registration order
- Verify the router is properly mounted
- Use debug endpoints to confirm routing works

### Lessons Learned

1. **Generic vs Custom 404**: FastAPI's default 404 `{"detail":"Not Found"}` is different from custom `HTTPException(status_code=404, detail="...")`. The former means no route matched.

2. **Debug Endpoints**: Adding `/debug/routes` and `/debug/test-content/{id}` endpoints helps isolate whether the issue is routing or business logic.

3. **Startup Logging**: Printing all registered routes at startup helps verify the router is mounted correctly.

4. **Variable Naming in React**: Avoid naming props `document` as it shadows the global `document` object. Use `doc` instead.

5. **Deployment Verification**: Always verify the latest code is actually deployed before extensive debugging.

### File Summary

| File | Change |
|------|--------|
| `backend/app/models/schemas.py` | Added `DocumentContentResponse` |
| `backend/app/services/document_service.py` | Added `get_document_content()` |
| `backend/app/routers/documents.py` | Added `GET /{doc_id}/content` + debug endpoints |
| `backend/app/main.py` | Added startup route logging |
| `frontend/lib/types.ts` | Added `DocumentContentResponse` interface |
| `frontend/lib/api.ts` | Added `fetchDocumentContent()` |
| `frontend/lib/constants.ts` | Added `documentLoading`, `documentLoadError` |
| `frontend/app/components/DocumentPreviewModal.tsx` | New modal component |
| `frontend/app/components/DocumentList.tsx` | Added `onPreview` prop |
| `frontend/app/components/DocumentDrawer.tsx` | Integrated preview modal |
| `frontend/app/components/ChatInterface.tsx` | Integrated preview modal |

---

## Stale Closure Bug in useChat Hook

### The Problem

AI was responding to old messages instead of the current conversation. When users asked a new question, the AI would sometimes answer based on stale conversation history.

**Reproduction steps:**
1. Click a suggested question
2. Wait for response
3. Ask a new question
4. AI responds to the old question instead of the new one

### Root Cause: React Stale Closure

The `useChat` hook had a classic React stale closure issue:

```typescript
// BUGGY CODE
const sendMessage = useCallback(async (content: string) => {
  // ...

  // This 'messages' is from when useCallback was created, NOT current!
  const history = messages.map((m) => ({
    role: m.role,
    content: m.content,
  }));

  // Sends stale history to the AI
  for await (const event of streamChat(content, history)) {
    // ...
  }
}, [messages, isLoading]); // Even with dependencies, timing issues occur
```

The problem: When `sendMessage` is called, the `messages` variable inside the callback refers to the value captured when the callback was created (previous render), not the current value. This is because JavaScript closures capture variables by reference at creation time.

### The Fix

**1. Use a ref for `isLoading` to avoid closure issues:**

```typescript
const isLoadingRef = useRef(false);

const sendMessage = useCallback(async (content: string) => {
  if (!content.trim() || isLoadingRef.current) return;

  isLoadingRef.current = true;
  // ...
}, []);
```

**2. Capture history inside `setMessages` functional update:**

```typescript
// FIXED CODE
let capturedHistory: Pick<Message, "role" | "content">[] = [];

setMessages((prev) => {
  // 'prev' is ALWAYS the current state - guaranteed by React
  capturedHistory = prev.map((m) => ({
    role: m.role,
    content: m.content,
  }));
  return [...prev, userMessage, assistantMessage];
});

// Now use the correctly captured history
for await (const event of streamChat(content, capturedHistory)) {
  // ...
}
```

**3. Remove dependencies from `useCallback`:**

```typescript
}, []); // No dependencies - uses refs and functional state updates
```

### Why This Works

- `setMessages((prev) => ...)` always receives the **current** state as `prev`
- By capturing history inside the functional update, we're guaranteed to get the latest messages
- Using `isLoadingRef` instead of `isLoading` state avoids the closure issue for the loading check
- Empty dependency array is now safe because we don't rely on any external values

### Key Takeaway: React Closure Pattern

When you need the **current** state value inside a callback (especially async ones), use one of these patterns:

| Pattern | When to Use |
|---------|-------------|
| `useRef` | For values you need to read but don't need to trigger re-renders |
| Functional `setState` | To capture current state at execution time |
| `useEffect` with ref sync | When you need the value but can't use functional update |

```typescript
// Pattern: Sync state to ref for reading in callbacks
const valueRef = useRef(value);
useEffect(() => {
  valueRef.current = value;
}, [value]);

// Now valueRef.current is always current in any callback
```

### Files Changed

| File | Change |
|------|--------|
| `frontend/hooks/useChat.ts` | Fixed stale closure by using ref and functional setState |

---

## Maya Avatar Feature

### Overview

Added an animated avatar character ("Maya") to the chat interface. The avatar appears to the left of each assistant message bubble and changes state based on the message's streaming status.

### Avatar States

| State | GIF File | Condition |
|-------|----------|-----------|
| Thinking | `maya-thinking.gif` | `isStreaming === true` AND `content === ""` |
| Speaking | `maya-speaking.gif` | `isStreaming === true` AND `content !== ""` |
| Idling | `maya-idling.gif` | `isStreaming === false` (message complete) |

### Implementation

#### 1. New Component: `MayaAvatar.tsx`

```typescript
export type AvatarState = "idling" | "speaking" | "thinking";

interface MayaAvatarProps {
  state: AvatarState;
  size?: number;
}

const avatarSrc: Record<AvatarState, string> = {
  idling: "/avatars/maya-idling.gif",
  speaking: "/avatars/maya-speaking.gif",
  thinking: "/avatars/maya-thinking.gif",
};

export function MayaAvatar({ state, size = 64 }: MayaAvatarProps) {
  return (
    <div
      className="shrink-0 rounded-full overflow-hidden bg-gray-100"
      style={{ width: size, height: size }}
    >
      <img
        src={avatarSrc[state]}
        alt={`Maya ${state}`}
        className="w-full h-full object-cover"
      />
    </div>
  );
}
```

#### 2. Updated `MessageBubble.tsx`

**Key changes:**
- Removed the old inline "AI アシスタント" indicator (small icon + text)
- Added avatar to the left of assistant message bubbles
- Split user and assistant message rendering for cleaner structure

```typescript
// Determine avatar state based on message streaming status
const avatarState: AvatarState = message.isStreaming
  ? message.content
    ? "speaking"
    : "thinking"
  : "idling";

// User messages: right-aligned, no avatar
if (isUser) {
  return (
    <div className="flex justify-end">
      <div className="max-w-[85%] ...">
        {message.content}
      </div>
    </div>
  );
}

// Assistant messages: left-aligned with avatar
return (
  <div className="flex justify-start">
    <div className="flex items-start gap-3 max-w-[90%]">
      <MayaAvatar state={avatarState} size={56} />
      <div className="bg-white ...">
        {/* message content, sources, loading indicator */}
      </div>
    </div>
  </div>
);
```

#### 3. GIF Preloading in `ChatInterface.tsx`

Since the GIFs are 2-3 MB each, preloading on mount ensures instant state transitions:

```typescript
useEffect(() => {
  const preloadImages = [
    "/avatars/maya-idling.gif",
    "/avatars/maya-speaking.gif",
    "/avatars/maya-thinking.gif",
  ];
  preloadImages.forEach((src) => {
    const img = new Image();
    img.src = src;
  });
}, []);
```

### Design Decisions

1. **Per-message state**: Each message bubble's avatar reflects that specific message's state, not a global state. Completed messages show idling Maya while the currently streaming message shows speaking/thinking.

2. **Avatar position**: Outside the bubble to the left (not inside) - cleaner separation and more prominent character presence.

3. **Avatar size**: 56px - large enough to see the animation clearly, but not overwhelming.

4. **Rounded avatar**: `rounded-full overflow-hidden` for a circular avatar appearance.

### Files Changed

| File | Change |
|------|--------|
| `frontend/app/components/MayaAvatar.tsx` | New component |
| `frontend/app/components/MessageBubble.tsx` | Added avatar, restructured layout |
| `frontend/app/components/ChatInterface.tsx` | Added GIF preloading |

### Assets

Located in `frontend/public/avatars/`:
- `maya-idling.gif` (~2.5 MB)
- `maya-speaking.gif` (~2.8 MB)
- `maya-thinking.gif` (~3.1 MB)

---

## 参照元 (Source Citations) Accuracy Fix

### The Original Problem

The "参照ソース" section below each assistant message was displaying **all documents retrieved by the RAG retriever**, not the sources actually cited by the LLM in its response.

**Example:**
- RAG retriever finds: `company_info.txt:1-47`, `policies.txt:50-105`, `policies.txt:1-54`
- LLM only cites: `[company_info.txt:17-19]` in its response
- "参照ソース" showed all 3 sources, which was misleading

This happened because:
1. The backend sends all retrieved documents via SSE "sources" event
2. The frontend displayed them directly without checking if they were actually used
3. The inline citations (e.g., `[company_info.txt:17-19]`) are generated by the LLM and may not match the retrieved chunks

### First Attempt: Exact Citation Extraction

Created a utility to parse exact citations from the message content:

```typescript
// citationUtils.ts
export function extractCitedSources(content: string, retrievedSources: Source[]): Source[] {
  const citationRegex = /\[([^\]:\s]+):(\d+)-(\d+)\]/g;
  // Parse [filename:start-end] patterns and match with retrieved sources
  // ...
}
```

**Problem with this approach:** The LLM might cite `[company_info.txt:17-19]` but the retrieved source has `startLine: 1, endLine: 47`. The exact match failed, leaving `contentPreview` empty because the line ranges didn't match.

### Final Fix: Filename-Based Filtering

Instead of exact citation matching, filter retrieved sources by checking if their filename appears anywhere in the response:

```typescript
// MessageBubble.tsx
const citedSources = message.sources.filter(source =>
  message.content.includes(source.filename)
);
```

**Why this works better:**
1. Preserves the `contentPreview` data from retrieved sources
2. More forgiving - LLM can cite any line range, we just check the filename
3. Simpler logic, no separate utility file needed

**Trade-off:** If the LLM mentions a filename without citing it (e.g., "This differs from policies.txt"), that file would still show. This is rare and acceptable.

### Label Change

Also renamed "参照ソース" to "参照元" for clarity.

### Inline Citation Styling

Added blue highlighting for inline citations to make them more prominent:

```typescript
function renderContentWithCitations(content: string): React.ReactNode {
  const citationRegex = /(\[[^\]:\s]+:\d+-\d+\])/g;
  const parts = content.split(citationRegex);

  return parts.map((part, index) => {
    if (citationRegex.test(part)) {
      citationRegex.lastIndex = 0; // Reset regex since we're reusing it
      return (
        <span key={index} className="text-blue-600 font-medium">
          {part}
        </span>
      );
    }
    return part;
  });
}
```

**How it works:**
1. Split content by citation pattern `[filename:start-end]`
2. The regex uses a capture group `()` so `split()` keeps the matched citations in the array
3. Map over parts, wrapping citations in a blue styled span
4. Reset `lastIndex` because `test()` with `/g` flag advances the index

### Files Changed

| File | Change |
|------|--------|
| `frontend/app/components/MessageBubble.tsx` | Filter sources by filename match, renamed label, added blue citation styling |
| `frontend/lib/citationUtils.ts` | Deleted (no longer needed) |

---

## Third Onboarding Callout: Upload Guide

### Overview

Added a third callout to the onboarding sequence that guides users through the document upload flow.

### New Onboarding Flow

```
1. OnboardingTooltip (welcome message) → dismiss →
2. PreviewHintCallout (click docs to preview) → dismiss →
3. UploadGuideCallout (opens drawer, explains upload → re-index) → dismiss → close drawer → focus chatbox
```

### Implementation

#### 1. Static Warning in DocumentDrawer

Added an amber warning box below the upload area to remind users about shared visibility:

```typescript
// DocumentDrawer.tsx
<div className="flex items-start gap-2 text-xs text-amber-700 bg-amber-50 border border-amber-200 rounded-lg p-2.5 mt-3">
  <svg>...</svg>
  <span>アップロードしたファイルは他のユーザーにも表示されます。使用後は削除してください。</span>
</div>
```

This is always visible in the drawer, not just during onboarding.

#### 2. UploadGuideCallout Component

New callout component (`UploadGuideCallout.tsx`) with:
- Emerald/teal gradient styling (different from previous callouts)
- Positioned to the left of the drawer (pointing right with arrow)
- z-index layering: backdrop at z-45, callout at z-55 (drawer is z-50)

```typescript
// Positioning to the left of the max-w-md drawer
style={{
  top: "50%",
  right: "calc(28rem + 16px)", // max-w-md (28rem) + gap
  transform: "translateY(-50%)",
}}
```

#### 3. ChatInput forwardRef

Updated `ChatInput` to use `forwardRef` and `useImperativeHandle` to expose a `focus()` method:

```typescript
export interface ChatInputRef {
  focus: () => void;
}

export const ChatInput = forwardRef<ChatInputRef, ChatInputProps>(
  function ChatInput({ onSend, disabled = false }, ref) {
    const textareaRef = useRef<HTMLTextAreaElement>(null);

    useImperativeHandle(ref, () => ({
      focus: () => textareaRef.current?.focus(),
    }));
    // ...
  }
);
```

#### 4. ChatInterface Callout Sequence

Updated the callout chain in `ChatInterface.tsx`:

```typescript
// PreviewHintCallout now triggers UploadGuideCallout
<PreviewHintCallout
  onDismiss={() => {
    setShowPreviewHint(false);
    setTimeout(() => {
      setShowUploadGuide(true);
      setIsDrawerOpen(true);  // Open drawer automatically
    }, 300);
  }}
  targetRef={documentChipsRef}
/>

// UploadGuideCallout closes drawer and focuses chat input
<UploadGuideCallout
  onDismiss={() => {
    setShowUploadGuide(false);
    setIsDrawerOpen(false);
    setTimeout(() => chatInputRef.current?.focus(), 100);
  }}
/>
```

#### 5. New Constants

```typescript
// lib/constants.ts
uploadGuideTitle: "ドキュメントをアップロード",
uploadGuideMessage: "ファイルをアップロード後、「インデックスを再構築」ボタンを押すと検索対象に追加されます。",
```

### Design Decisions

1. **Static warning vs callout**: The "delete after use" reminder is a static element in the drawer rather than part of the callout, so users always see it when uploading.

2. **Callout positioning**: Points at the drawer from the left side rather than targeting a specific element inside the drawer - simpler implementation and still effective.

3. **Focus chatbox**: After the final callout, the chat input is focused automatically so users can immediately start typing.

4. **Color differentiation**: Each callout uses different gradient colors:
   - OnboardingTooltip: Blue
   - PreviewHintCallout: Indigo/Purple
   - UploadGuideCallout: Emerald/Teal

### Files Changed

| File | Change |
|------|--------|
| `frontend/app/components/UploadGuideCallout.tsx` | New callout component |
| `frontend/app/components/DocumentDrawer.tsx` | Added amber warning about shared visibility |
| `frontend/app/components/ChatInput.tsx` | Added forwardRef to expose focus() method |
| `frontend/app/components/ChatInterface.tsx` | Added third callout to sequence, focus chatbox on completion |
| `frontend/lib/constants.ts` | Added uploadGuideTitle and uploadGuideMessage |
