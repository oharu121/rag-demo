# RAG Learning Notes - 2025-12-02

## Document Preview Modal Feature

### Overview

Added a feature to preview document contents in a modal when clicking on document items (both in the welcome screen document chips and in the document management drawer).

### Implementation

#### Backend Changes

**1. New Schema (`backend/app/models/schemas.py`)**

```python
class DocumentContentResponse(BaseModel):
    """ドキュメント内容レスポンス"""
    id: str
    filename: str
    content: str
    line_count: int
```

**2. New Service Method (`backend/app/services/document_service.py`)**

```python
def get_document_content(self, doc_id: str) -> tuple[DocumentInfo, str]:
    """ドキュメントの内容を取得"""
    # サンプルドキュメントを検索
    for file_path in self.settings.documents_dir.glob("**/*.txt"):
        content = file_path.read_text(encoding="utf-8")
        if self._generate_id(file_path.name, content) == doc_id:
            # ... return doc_info, content

    # アップロードされたドキュメントを検索
    for file_path in self.settings.uploads_dir.glob("**/*.txt"):
        content = file_path.read_text(encoding="utf-8")
        if self._generate_id(file_path.name, content) == doc_id:
            # ... return doc_info, content

    raise DocumentException(ErrorMessages.DOCUMENT_NOT_FOUND, "NOT_FOUND")
```

**3. New Endpoint (`backend/app/routers/documents.py`)**

```python
@router.get("/{doc_id}/content", response_model=DocumentContentResponse)
async def get_document_content(doc_id: str) -> DocumentContentResponse:
    """ドキュメントの内容を取得"""
    doc_service = get_document_service()
    doc_info, content = doc_service.get_document_content(doc_id)
    return DocumentContentResponse(
        id=doc_info.id,
        filename=doc_info.filename,
        content=content,
        line_count=doc_info.line_count,
    )
```

#### Frontend Changes

**1. New Type (`frontend/lib/types.ts`)**

```typescript
export interface DocumentContentResponse {
  id: string;
  filename: string;
  content: string;
  line_count: number;
}
```

**2. New API Function (`frontend/lib/api.ts`)**

```typescript
export async function fetchDocumentContent(
  docId: string
): Promise<{ content: string; filename: string; lineCount: number }> {
  const response = await fetch(
    `${baseUrl}${endpoints.documents}/${docId}/content`
  );
  // ... error handling
  const data: DocumentContentResponse = await response.json();
  return {
    content: data.content,
    filename: data.filename,
    lineCount: data.line_count,
  };
}
```

**3. New Component (`frontend/app/components/DocumentPreviewModal.tsx`)**

A modal component that:
- Takes a `doc` prop (Document | null)
- Fetches content on mount using `useEffect`
- Shows loading spinner while fetching
- Displays error message if fetch fails
- Renders document content in a scrollable `<pre>` block
- Closes on backdrop click or Escape key

**4. Updated Components**

- `DocumentList.tsx`: Added `onPreview` prop to make items clickable
- `DocumentDrawer.tsx`: Added modal state and integrated `DocumentPreviewModal`
- `ChatInterface.tsx`: Added modal state for welcome screen document chips

### Debugging the 404 Issue

Initially, the endpoint returned a generic FastAPI 404 `{"detail":"Not Found"}` instead of our custom error. This indicated the route wasn't being matched.

#### Debug Approach

**1. Added debug routes endpoint:**

```python
@router.get("/debug/routes")
async def debug_routes():
    """デバッグ用: ルート確認"""
    return {
        "message": "Documents router is working",
        "available_routes": [...]
    }
```

**2. Added test endpoint with detailed response:**

```python
@router.get("/debug/test-content/{doc_id}")
async def debug_test_content(doc_id: str):
    """デバッグ用: コンテンツエンドポイントのテスト"""
    doc_service = get_document_service()
    all_docs = doc_service.list_documents()
    doc_ids = [d.id for d in all_docs]
    return {
        "received_doc_id": doc_id,
        "available_doc_ids": doc_ids,
        "doc_id_found": doc_id in doc_ids,
    }
```

**3. Added startup route logging (`backend/app/main.py`):**

```python
# 登録されたルートを出力
print("=" * 50, flush=True)
print("登録されたルート:", flush=True)
for route in app.routes:
    if hasattr(route, "methods") and hasattr(route, "path"):
        print(f"  {route.methods} {route.path}", flush=True)
print("=" * 50, flush=True)
```

**4. Added detailed logging in endpoint:**

```python
print(f"[DEBUG] get_document_content called with doc_id: {doc_id}", flush=True)
print(f"[DEBUG] Searching for document: {doc_id}", flush=True)
print(f"[DEBUG] Found document: {doc_info.filename}", flush=True)
```

#### Key Insight: FastAPI Route Matching

When getting a generic `{"detail":"Not Found"}` from FastAPI, it means:
- The route itself isn't being matched (not our custom error)
- Check route registration order
- Verify the router is properly mounted
- Use debug endpoints to confirm routing works

### Lessons Learned

1. **Generic vs Custom 404**: FastAPI's default 404 `{"detail":"Not Found"}` is different from custom `HTTPException(status_code=404, detail="...")`. The former means no route matched.

2. **Debug Endpoints**: Adding `/debug/routes` and `/debug/test-content/{id}` endpoints helps isolate whether the issue is routing or business logic.

3. **Startup Logging**: Printing all registered routes at startup helps verify the router is mounted correctly.

4. **Variable Naming in React**: Avoid naming props `document` as it shadows the global `document` object. Use `doc` instead.

5. **Deployment Verification**: Always verify the latest code is actually deployed before extensive debugging.

### File Summary

| File | Change |
|------|--------|
| `backend/app/models/schemas.py` | Added `DocumentContentResponse` |
| `backend/app/services/document_service.py` | Added `get_document_content()` |
| `backend/app/routers/documents.py` | Added `GET /{doc_id}/content` + debug endpoints |
| `backend/app/main.py` | Added startup route logging |
| `frontend/lib/types.ts` | Added `DocumentContentResponse` interface |
| `frontend/lib/api.ts` | Added `fetchDocumentContent()` |
| `frontend/lib/constants.ts` | Added `documentLoading`, `documentLoadError` |
| `frontend/app/components/DocumentPreviewModal.tsx` | New modal component |
| `frontend/app/components/DocumentList.tsx` | Added `onPreview` prop |
| `frontend/app/components/DocumentDrawer.tsx` | Integrated preview modal |
| `frontend/app/components/ChatInterface.tsx` | Integrated preview modal |

---

## Stale Closure Bug in useChat Hook

### The Problem

AI was responding to old messages instead of the current conversation. When users asked a new question, the AI would sometimes answer based on stale conversation history.

**Reproduction steps:**
1. Click a suggested question
2. Wait for response
3. Ask a new question
4. AI responds to the old question instead of the new one

### Root Cause: React Stale Closure

The `useChat` hook had a classic React stale closure issue:

```typescript
// BUGGY CODE
const sendMessage = useCallback(async (content: string) => {
  // ...

  // This 'messages' is from when useCallback was created, NOT current!
  const history = messages.map((m) => ({
    role: m.role,
    content: m.content,
  }));

  // Sends stale history to the AI
  for await (const event of streamChat(content, history)) {
    // ...
  }
}, [messages, isLoading]); // Even with dependencies, timing issues occur
```

The problem: When `sendMessage` is called, the `messages` variable inside the callback refers to the value captured when the callback was created (previous render), not the current value. This is because JavaScript closures capture variables by reference at creation time.

### The Fix

**1. Use a ref for `isLoading` to avoid closure issues:**

```typescript
const isLoadingRef = useRef(false);

const sendMessage = useCallback(async (content: string) => {
  if (!content.trim() || isLoadingRef.current) return;

  isLoadingRef.current = true;
  // ...
}, []);
```

**2. Capture history inside `setMessages` functional update:**

```typescript
// FIXED CODE
let capturedHistory: Pick<Message, "role" | "content">[] = [];

setMessages((prev) => {
  // 'prev' is ALWAYS the current state - guaranteed by React
  capturedHistory = prev.map((m) => ({
    role: m.role,
    content: m.content,
  }));
  return [...prev, userMessage, assistantMessage];
});

// Now use the correctly captured history
for await (const event of streamChat(content, capturedHistory)) {
  // ...
}
```

**3. Remove dependencies from `useCallback`:**

```typescript
}, []); // No dependencies - uses refs and functional state updates
```

### Why This Works

- `setMessages((prev) => ...)` always receives the **current** state as `prev`
- By capturing history inside the functional update, we're guaranteed to get the latest messages
- Using `isLoadingRef` instead of `isLoading` state avoids the closure issue for the loading check
- Empty dependency array is now safe because we don't rely on any external values

### Key Takeaway: React Closure Pattern

When you need the **current** state value inside a callback (especially async ones), use one of these patterns:

| Pattern | When to Use |
|---------|-------------|
| `useRef` | For values you need to read but don't need to trigger re-renders |
| Functional `setState` | To capture current state at execution time |
| `useEffect` with ref sync | When you need the value but can't use functional update |

```typescript
// Pattern: Sync state to ref for reading in callbacks
const valueRef = useRef(value);
useEffect(() => {
  valueRef.current = value;
}, [value]);

// Now valueRef.current is always current in any callback
```

### Files Changed

| File | Change |
|------|--------|
| `frontend/hooks/useChat.ts` | Fixed stale closure by using ref and functional setState |
